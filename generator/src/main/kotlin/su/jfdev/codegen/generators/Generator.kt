package su.jfdev.codegen.generators

import java.io.*

abstract class Generator {
    fun generate(gen: Gen) = CodeWriter(gen).use {
        it.write(gen)
    }

    protected abstract fun CodeWriter.write(gen: Gen)

    inner class CodeWriter(gen: Gen): Closeable {
        private val pack = gen.pack
        private val cfg = gen.configuration
        private val writer = File(pack.output, gen.name + gen.configuration.extension).run {
            if (!exists()) {
                parentFile.mkdirs()
                createNewFile()
            }
            bufferedWriter()
        }

        override fun close() = writer.close()

        fun file(name: String) = annotation("""JvmName("$name")""")
        fun multifile(name: String) {
            file(name)
            annotation("""JvmMultifileClass""")
        }

        fun suppress(vararg types: String) = annotation("Suppress(${packSuppress(types)})")
        private fun packSuppress(types: Array<out String>) = types.map { """"$it"""" }.joinToString()

        fun annotation(annotation: String) = +"@file:$annotation"
        fun _package(_package: String = pack.`package`.toString()) = +"package $_package"
        fun author() = comment("Generated by ${cfg.author}")
        fun comment(text: String) = +"//$text"

        operator fun String.unaryPlus() = transform().apply {
            writer.appendln(this)
        }

        operator fun String.unaryMinus() = transform().apply {
            writer.append(this)
        }

        private fun String.transform(): String = when {
            isNotEmpty() -> multiReplace()
            else         -> this
        }

        private fun String.multiReplace(): String {
            var result: String = this
            while (true) result = result.replace() ?: return result
        }

        private fun String.replace(): String? {
            var result = this
            var hasEffect: Boolean = false
            for ((from, to) in cfg.replacements) if (from in result) {
                hasEffect = true
                result = result.replace(from, to)
            }
            return if (hasEffect) result else null
        }
    }

    companion object {
        operator fun invoke(gen: CodeWriter.(Gen) -> Unit) = object: Generator() {
            override fun CodeWriter.write(gen: Gen) {
                gen(gen)
            }
        }
    }
}
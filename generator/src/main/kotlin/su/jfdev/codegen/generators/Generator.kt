package su.jfdev.codegen.generators

import java.io.*
import java.util.*

abstract class Generator {
    fun generate(gen: Gen) = CodeWriter(gen).use {
        it.write(gen)
    }

    protected abstract fun CodeWriter.write(gen: Gen)

    inner class CodeWriter(gen: Gen): Closeable {
        private val pack = gen.pack
        private val cfg = gen.configuration
        private val replacements = cfg.replacements.toMap(HashMap())
        private val ignore = ArrayList<String>()
        private val writer = File(pack.output, gen.name + gen.configuration.extension).run {
            if (!exists()) {
                parentFile.mkdirs()
                createNewFile()
            }
            println("write to $this")
            bufferedWriter()
        }

        override fun close() = writer.close()

        fun file(name: String) = annotation("""JvmName("$name")""")
        fun multifile(name: String) {
            file(name)
            annotation("""JvmMultifileClass""")
        }

        fun suppress(vararg types: String) = annotation("Suppress(${packSuppress(types)})")
        private fun packSuppress(types: Array<out String>) = types.map { """"$it"""" }.joinToString()

        fun annotation(annotation: String) = +"@file:$annotation"
        fun _package(_package: String) = +"package $_package"
        fun author() = comment("Generated by ${cfg.author}")
        fun comment(text: String) = +"//$text"

        operator fun String.unaryPlus() = transform().apply {
            writer.appendln(this)
        }

        operator fun String.unaryMinus() = transform().apply {
            writer.append(this)
        }

        private fun String.transform(): String = when {
            startsWith(DEFINE)   -> apply { define() }
            startsWith(UNDEFINE) -> apply { undefine() }
            isNotEmpty()         -> multiReplace()
            else                 -> this
        }

        private fun String.define() {
            val pair = substringAfter(DEFINE).trim()
            replacements += Pair(first = pair.substringBefore("="), second = pair.substringAfter("="))
        }

        private fun String.undefine() {
            val target = substringAfter(UNDEFINE).trim()
            replacements.remove(target)
        }

        private fun String.multiReplace(): String {
            var result: String = this
            ignore.clear()
            while (true) result = result.replace() ?: return result
        }

        private fun String.replace(): String? {
            var result = this
            var hasEffect: Boolean = false
            for ((from, to) in cfg.replacements) if (from !in ignore && from in result) {
                hasEffect = true
                result = result.replace(from, to)
            }
            return if (hasEffect) result else null
        }
    }

    companion object {
        private const val DEFINE = "//define "
        private const val UNDEFINE = "//undefine "
        operator fun invoke(gen: CodeWriter.(Gen) -> Unit) = object: Generator() {
            override fun CodeWriter.write(gen: Gen) {
                gen(gen)
            }
        }
    }
}